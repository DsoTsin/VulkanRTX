<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw');ol{margin:0;padding:0}table td,table th{padding:0}.c11{-webkit-text-decoration-skip:none;color:#1155cc;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-family:"Arial";font-style:normal}.c18{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:28pt;font-family:"Arial";font-style:normal}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c3{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c5{padding-top:10pt;padding-bottom:4pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c2{padding-top:10pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c7{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:left}.c16{text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c13{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#954f72;text-decoration:underline}.c15{vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c12{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c20{font-size:9.5pt;font-family:"Consolas";font-weight:400}.c8{font-family:"Consolas";color:#0000ff;font-weight:400}.c14{font-size:7pt;font-family:"Times New Roman";font-weight:400}.c17{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c4{color:inherit;text-decoration:inherit}.c19{height:11pt}.c0{font-weight:700}.c9{color:#0000ff}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c17"><h1 class="c7" id="h.j3butbprteem"><span class="c10">Introduction</span></h1><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>Welcome to the VkRay tutorials. In these tutorials we are going to look at the basics of the </span><span class="c13"><a class="c4" href="https://www.google.com/url?q=https://developer.nvidia.com/rtx/raytracing&amp;sa=D&amp;ust=1542123713358000">ray tracing</a></span><span>&nbsp;using </span><span class="c13"><a class="c4" href="https://www.google.com/url?q=https://www.khronos.org/vulkan/&amp;sa=D&amp;ust=1542123713358000">Vulkan API</a></span><span class="c1">. Tutorials will lead you from the beginning doing the initialization step-by-step moving to the complete example of the API usage. Each tutorial has the list of files which were created during it and may be used in the later tutorials. It is recommended to open tutorial files linked at the start of the each tutorial and read the code following along the tutorial text.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><h1 class="c7" id="h.odhktj1ivq17"><span class="c10">Contents</span></h1><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Here is the list of the tutorials.</span></p><p class="c2"><span class="c12"><a class="c4" href="#h.h2y360emcggh">Tutorial 1: Init Ray Tracing</a></span></p><p class="c2"><span class="c12"><a class="c4" href="#h.xz4diptvg0og">Tutorial 2: Acceleration Structure</a></span></p><p class="c2"><span class="c12"><a class="c4" href="#h.zc89ebzbbmra">Tutorial 3: Pipeline</a></span></p><p class="c2"><span class="c12"><a class="c4" href="#h.ba9ffl2tw5sv">Tutorial 4: Descriptor Set</a></span></p><p class="c2"><span class="c12"><a class="c4" href="#h.18jo53ynpcsl">Tutorial 5: Ray Generation</a></span></p><p class="c2"><span class="c12"><a class="c4" href="#h.wllphdhw6h78">Tutorial 6: Shaders</a></span></p><p class="c2"><span class="c12"><a class="c4" href="#h.uslk3mt31qos">Tutorial 7: Instance Buffer</a></span></p><p class="c2"><span class="c12"><a class="c4" href="#h.kb10vq8kjxv6">Tutorial 8: Animate and Refit</a></span></p><p class="c2"><span class="c12"><a class="c4" href="#h.jhlf16ax5rr4">Tutorial 9: Secondary Rays</a></span></p><p class="c2"><span class="c12"><a class="c4" href="#h.frymb2gvwbgb">Tutorial 10: Instance Resources</a></span></p><p class="c5"><span class="c12"><a class="c4" href="#h.w0pn50dujcgy">Tutorial 11: Different Vertex Formats</a></span></p><p class="c6 c19"><span class="c1"></span></p><h1 class="c7" id="h.h2y360emcggh"><span class="c10">Tutorial 1: Init Ray Tracing</span></h1><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Tutorial files:</span></p><p class="c6"><span class="c3 c0">Application.h</span></p><p class="c6"><span class="c3 c0">Application.cpp</span></p><p class="c6"><span class="c0">01_InitRayTracing.cpp</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>We begin by defining application basis for the other tutorials. </span><span class="c0">Application.h/Application.cpp</span><span>&nbsp;files contain code for the </span><span class="c8">Application</span><span class="c9">&nbsp;</span><span class="c1">class which takes care of the window creation, Vulkan initialization and main loop. It also includes several helper classes for dealing with resources, i.e. images, shaders, buffers, which encapsulate common Vulkan code. Their purpose is to reduce code clutter in the following tutorials.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c8">TutorialApplication</span><span class="c9">&nbsp;</span><span>class inherits from the </span><span class="c8">Application</span><span class="c9">&nbsp;</span><span class="c1">and shows how to properly create device with ray tracing extension enabled, resolve ray tracing specific function pointers and ray tracing properties which will be used throughout rest of the tutorials.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><h1 class="c7" id="h.xz4diptvg0og"><span class="c10">Tutorial 2: Acceleration Structure</span></h1><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Tutorial files:</span></p><p class="c6"><span class="c3 c0">RayTracingApplication.h</span></p><p class="c6"><span class="c3 c0">RayTracingApplication.cpp</span></p><p class="c6"><span class="c0">02_AccelerationStructure.cpp</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>The tutorial introduces </span><span class="c8">RayTracingApplication</span><span class="c1">&nbsp;class with the code developed in the Tutorial 1 to keep all the basic ray tracing functionality in one place. Upcoming tutorial classes will be inherited from this one.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>Main goal of this tutorial is to show how to create and fill acceleration structures (</span><span class="c8">VkAccelerationStructureNV</span><span>). To use ray tracing functionality users have to convert their geometry data into API specific form. Take a brief look at </span><span class="c8">CreateAccelerationStructures()</span><span>&nbsp;function. It shows the process step by step. We begin with creating regular vertex and index buffers which contain scene geometry to be traced. To simplify the code, we will use only single triangle. The API does not use buffers directly, so we must create and fill one or more </span><span class="c8">VkGeometryNV</span><span class="c1">&nbsp;structs. These are used in the following steps.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>The geometry is organized into two levels: bottom and top. For each of the levels we must create acceleration structures (referred further as AS). Bottom level AS wraps actual geometry data, while top level manages bottom level ones. For example, imagine the scene that contains the table and many chairs. In this case we will have only 2 bottom level AS (one for the table and one for the chair) and one top level AS linking to the bottom level ones. AS creation process consists of two steps: creation and building. At first, we create both AS using </span><span class="c8">vkCreateAccelerationStructureNV()</span><span>, allocating and binding memory to the handle (the process is similar to creating regular Vulkan buffer). As the result we have </span><span class="c8">VkAccelerationStructureNV</span><span class="c9">&nbsp;</span><span>and </span><span class="c8">VkDeviceMemory</span><span class="c9">&nbsp;</span><span class="c1">per AS.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>Next, we create instance buffers. You can have single geometry object, however, it&rsquo;s possible to have many instances of the same geometry with various transforms and properties. This is where instance buffers come into play. Regular Vulkan buffer is created and filled with </span><span class="c8">VkGeometryInstance</span><span class="c9">&nbsp;</span><span class="c1">structs (one per instance). In our case it&rsquo;s single instance, i.e. only one triangle will be shown. Using the scene example above &ndash; every chair should have its own instance object.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>Finally, AS instances must be built. The process uses scratch buffer (it&rsquo;s regular Vulkan buffer used internally during the calculations) and all the data we have prepared so far. Build process is done on the command buffer using memory barriers via </span><span class="c8">vkCmdBuildAccelerationStructureNV()</span><span class="c1">&nbsp;method. Building will transform the provided geometry into highly efficient format used during the ray tracing process.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Do not forget to destroy the allocated resources. Class destructor will take care of all created objects (we will not mention resource clean-up in the following tutorials, however you can always look at the destructor).</span></p><p class="c6"><span class="c1">&nbsp;</span></p><h1 class="c7" id="h.zc89ebzbbmra"><span class="c10">Tutorial 3: Pipeline</span></h1><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Tutorial files:</span></p><p class="c6"><span class="c3 c0">03_Pipeline.cpp</span></p><p class="c6"><span class="c0">rt_basic.rgen</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>Continuing from where Tutorial 2 left off, we will now create </span><span class="c8">VkPipeline</span><span class="c1">&nbsp;object which references ray tracing objects.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>Here we begin by creating </span><span class="c8">VkDescriptorSetLayout/VkPipelineLayout</span><span class="c1">&nbsp;objects. We will use two bindings here - one for the top level acceleration structure and one for the storage image. This image will contain the result of the tracing in the following tutorials as we won&rsquo;t trace anything in this tutorial yet.</span></p><p class="c6"><span>Ray tracing pipeline creation process differs from the regular Vulkan code. </span><span class="c8">VkRayTracingPipelineCreateInfoNV</span><span>&nbsp;struct must be filled and passed to </span><span class="c8">vkCreateRaytracingPipelinesNV()</span><span>&nbsp;method. Notably, we have to fill in shader stages and groups before doing that. Ray tracing introduces several new shader types, including ray generation, any hit, closest hit, miss and others. They have corresponding enum entries in </span><span class="c8">VkShaderStageFlagBits</span><span class="c1">, i.e.:</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>&middot;</span><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c16 c8">VK_SHADER_STAGE_RAYGEN_BIT_NV</span></p><p class="c6"><span>&middot;</span><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c16 c8">VK_SHADER_STAGE_ANY_HIT_BIT_NV</span></p><p class="c6"><span>&middot;</span><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c16 c8">VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV</span></p><p class="c6"><span>&middot;</span><span class="c14">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c8 c16">VK_SHADER_STAGE_MISS_BIT_NV</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>All tutorial shaders are contained in the </span><span class="c0">Source/Shaders</span><span>&nbsp;folder alongside the compiler and batch file which launches the compilation. At this point we only load single ray generation shader </span><span class="c0">rt_basic.rgen</span><span>. It is minimalistic shader which does not do any ray tracing yet, only stores UV coordinates calculated from the current pixel (in the same manner as compute shaders do) in the provided image. Notice new variable semantic </span><span class="c8">rayPayloadNV</span><span>&nbsp;which is not currently used but will be used during the tracing in the future. Of course, to compile this (and all other ray tracing shaders) we must request special shader extension </span><span class="c8">GL_NV_ray_tracing</span><span class="c1">.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>To create the pipeline, we also need to describe shader groups. A group is represented by the </span><span class="c8">VkRayTracingShaderGroupCreateInfoNV</span><span class="c1">&nbsp;struct. Groups setup the ray tracing process, i.e. which shaders are called in which order, linking to the actual shaders loaded previously. We only have single shader in this tutorial thus only single group is created. However, there will be more groups in the further tutorials.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>Now we have all required data structures and can finally create the pipeline. Notice that while we use </span><span class="c8">VkRayTracingPipelineCreateInfoNV/ vkCreateRayTracingPipelinesNV() </span><span>to create the pipeline, the result is represented by the standard </span><span class="c8">VkPipeline</span><span>&nbsp;handle. Binding and destroying done as usual in Vulkan. Pipeline binding is done in the </span><span class="c8">RecordCommandBufferForFrame()</span><span class="c1">&nbsp;function. We will add more code to this function eventually.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><h1 class="c7" id="h.ba9ffl2tw5sv"><span class="c10">Tutorial 4: Descriptor Set</span></h1><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Tutorial files:</span></p><p class="c6"><span class="c0">04_DescriptorSet.cpp</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>This tutorial adds two new functions: </span><span class="c8">CreateShaderBindingTable()</span><span>&nbsp;and </span><span class="c8">CreateDescriptorSet()</span><span class="c1">.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>Shader binding table (SBT for short) is the regular host visible Vulkan buffer filled with data about the shader groups (mentioned in the previous tutorial). It can also contain additional user data available during the shader execution (this will be demonstrated in the separate tutorial). SBT is created and then mapped as usual buffer. After that </span><span class="c8">vkGetRayTracingShaderGroupHandlesNV()</span><span>&nbsp;must be called to fill the SBT. We only have single group so far, so we start at </span><span class="c8">firstGroup</span><span>&nbsp;0 and </span><span class="c8">groupCount</span><span class="c1">&nbsp;is 1. Notice that SBT is not used in this tutorial, however will be used in the following tutorial as the parameter to the trace function.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c8">CreateDescriptorSet()</span><span>&nbsp;contains mostly regular Vulkan code. Recall from the Tutorial 3 that we have two bindings in the layout, so we will need two descriptors. The only unusual code you will find here is </span><span class="c8">VkWriteDescriptorSetAccelerationStructureNV</span><span class="c9">&nbsp;</span><span>struct that is referenced by the </span><span class="c8">pNext</span><span class="c9">&nbsp;</span><span>field of the AS </span><span class="c8">VkWriteDescriptorSet</span><span class="c9">&nbsp;</span><span class="c1">that is easy to overlook. Image write descriptor is done regularly.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>In addition to the pipeline binding we also bind the descriptor set in the </span><span class="c8">RecordCommandBufferForFrame()</span><span class="c1">&nbsp;function now.</span></p><hr style="page-break-before:always;display:none;"><p class="c6 c19"><span class="c1"></span></p><p class="c6"><span class="c1">&nbsp;</span></p><h1 class="c7" id="h.18jo53ynpcsl"><span class="c10">Tutorial 5: Ray Generation</span></h1><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 366.67px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 366.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Tutorial files:</span></p><p class="c6"><span class="c0">05_RayGen.cpp</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>The tutorial will finally show something on the screen. The only difference with Tutorial 4 is in the </span><span class="c8">RecordCommandBufferForFrame()</span><span>&nbsp;function. To invoke the ray tracing we call </span><span class="c8">vkCmdTraceRaysNV()</span><span class="c1">&nbsp;method. This call sets things in motion and execute raytracing shaders. On the input it has several parameters using SBT and the tracing area size (width, height, depth &ndash; similar to compute shaders dispatch).</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>Recall that currently bound ray generation shader (</span><span class="c0">rt_basic.rgen</span><span>) does not do actual tracing, but only outputs UV coordinates calculated from the pixel position. It&rsquo;s calculated using </span><span class="c8">gl_LaunchIDNV</span><span>&nbsp;and </span><span class="c8">gl_LaunchSizeNV</span><span>&nbsp;built-in variables representing index of the current pixel and the dimensions passed to the </span><span class="c8">vkCmdTraceRaysNV()</span><span class="c1">&nbsp;method accordingly.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><h1 class="c7" id="h.wllphdhw6h78"><span class="c10">Tutorial 6: Shaders</span></h1><p class="c6"><span>&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 366.67px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 366.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Tutorial files:</span></p><p class="c6"><span class="c3 c0">06_Shaders.cpp</span></p><p class="c6"><span class="c3 c0">rt_06_shaders.rgen</span></p><p class="c6"><span class="c3 c0">rt_06_shaders.rchit</span></p><p class="c6"><span class="c3 c0">rt_06_shaders.rmiss</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">In this tutorial we will do some real ray tracing! The tutorial uses new set of shaders which do simplistic tracing which results in the colored triangle drawn on the screen. The only change on the application side comprises of the new shaders loading and groups (there will be 3 groups now, one per generation, hit and miss routines).</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c0">rt_06_shaders.rgen </span><span>shader uses new </span><span class="c8">traceNV()</span><span>&nbsp;function which does actual tracing and use ray origin, direction, payload and other parameters as the input. </span><span class="c0">rt_06_shaders.rmiss </span><span>shader will be called when no intersection has happened (i.e. ray has missed all the triangles) and will return the background color. </span><span class="c0">rt_06_shaders.rchit </span><span>shader will be called on the closest triangle hit and will output barycentric coordinates of the hit point (interpreted as the color) using </span><span class="c8">hitAttributeNV</span><span>&nbsp;semantic. In any case </span><span class="c8">rayPayloadInNV</span><span>&nbsp;variable semantic is used to write the resulting value (referenced as </span><span class="c8">rayPayloadNV</span><span>&nbsp;in the ray generation shader and is linked by the </span><span class="c8">location</span><span class="c1">&nbsp;index).</span></p><p class="c6"><span class="c1">&nbsp;</span></p><h1 class="c7" id="h.uslk3mt31qos"><span class="c10">Tutorial 7: Instance Buffer</span></h1><p class="c6"><span>&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 366.67px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 366.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Tutorial files:</span></p><p class="c6"><span class="c0">07_InstanceBuffer.cpp</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">As was noted in previous tutorials we can have many instances of the same geometry in the scene. This tutorial shows slightly more advanced usage of the instance structs than simply drawing the triangle.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>The changes are in the </span><span class="c8">CreateAccelerationStructures()</span><span>&nbsp;function. First, vertex/index buffers now contain data for the triangle, the quad and the icosahedron (geometry array contains 3 elements as well). Second, we create 3 bottom level AS instead of 1 (one per primitive). Third, we create 5 instances in total &ndash; 3 for the triangle, 1 for the quad and 1 for the icosahedron. Notice that we change </span><span class="c8">transform</span><span>&nbsp;member of the </span><span class="c8">VkGeometryInstance</span><span class="c1">&nbsp;struct to change instance placement.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><h1 class="c7" id="h.kb10vq8kjxv6"><span class="c10">Tutorial 8: Animate and Refit</span></h1><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 366.67px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 366.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Tutorial files:</span></p><p class="c6"><span class="c0">08_AnimateAndRefit.cpp</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>To support non-static geometry, we should update acceleration structures every frame so that we always have up to date data for the ray tracing routines. However, building AS from the scratch every frame is not very performant solution. To address this problem we can update AS using the call to </span><span class="c8">vkCmdBuildAccelerationStructureNV()</span><span class="c1">&nbsp;instead of doing full rebuild.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>The gist of the tutorial is in the </span><span class="c8">RecordCommandBufferForFrame()</span><span>&nbsp;function. In addition to the regular binding and tracing functions we also call </span><span class="c8">vkCmdBuildAccelerationStructureNV()</span><span>&nbsp;to update bottom and top level acceleration structures (notice </span><span class="c8">VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV</span><span>&nbsp;flag passed to the </span><span class="c8">VkAccelerationStructureInfoNV</span><span>&nbsp;struct and </span><span class="c8">VK_TRUE</span><span>&nbsp;passed to the </span><span class="c8">update</span><span>&nbsp;parameter). The animation is done in the </span><span class="c8">UpdateDataForFrame()</span><span class="c1">&nbsp;function. It is possible to change vertex data, instance data or both before rebuilding acceleration structures. As a result, we get the animated triangle being ray traced.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><h1 class="c7" id="h.jhlf16ax5rr4"><span class="c10">Tutorial 9: Secondary Rays</span></h1><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 366.67px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 366.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Tutorial files:</span></p><p class="c6"><span class="c3 c0">09_SecondaryRays.cpp</span></p><p class="c6"><span class="c3 c0">rt_09_first.rgen</span></p><p class="c6"><span class="c3 c0">rt_09_first.rchit</span></p><p class="c6"><span class="c3 c0">rt_09_first.rmiss</span></p><p class="c6"><span class="c3 c0">rt_09_secondary.rchit</span></p><p class="c6"><span class="c0">rt_09_secondary.rmiss</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">So far, we have only used single ray per pixel, terminating the tracing at the point of the first triangle hit. This tutorial features casting another set of rays upon hit. Notice new set of shaders, which contains shaders for the secondary hits and miss.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>Ray generation shader calls </span><span class="c8">traceNV()</span><span>&nbsp;as before. First miss shader returns background color as expected. First closest hit shader, however, calls </span><span class="c8">traceNV()</span><span>&nbsp;once again specifying secondary hit and miss shaders in its parameters. Origin of the second trace is the hit point of the first trace. The direction is set to the imaginary light source (in this case it&rsquo;s the opposite direction of the directional light). Notice that the sphere is also self-shadowed due to rays hit the sphere from the inside. Result of the second tracing is used to determine whether the point is in shadow or not (as secondary hit and miss return </span><span class="c8">gl_HitTNV</span><span class="c9">&nbsp;</span><span>and </span><span class="c8">gl_RayTmaxNV</span><span class="c9">&nbsp;</span><span>accordingly). We multiply this by the triangle color to get the final color. There is also one interesting detail contained in the </span><span class="c0">rt_09_first.rchit</span><span>&nbsp;shader &ndash; usage of the </span><span class="c8">gl_RayFlagsTerminateOnFirstHitNV</span><span class="c1">&nbsp;flag. It means that whenever we got any intersection (not necessary the closest one) closest hit shader will be called and the process will terminate. This makes sense due to it does not really matter which object blocked the light source thus casting a shadow.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>On the application side we have 5 shader groups now: generation, first hit, second hit, first miss, second miss. Don&rsquo;t forget that </span><span class="c8">vkCmdTraceRaysNV()</span><span>&nbsp;function should properly get offsets to the shaders as shown in the </span><span class="c8">RecordCommandBufferForFrame()</span><span>. Pay attention to the parameters to </span><span class="c8">traceNV()</span><span>&nbsp;method in the </span><span class="c0">rt_09_first.rchit</span><span>&nbsp;shader. </span><span class="c8">sbtRecordOffset</span><span>&nbsp;and </span><span class="c8">missIndex</span><span>&nbsp;parameters are set to 1 now to indicate secondary hit and miss shaders. This correlates with the parameters passed to </span><span class="c8">vkCmdTraceRaysNV()</span><span class="c1">&nbsp;function. Index of 1 means the offset relative to the according hit/miss shader binding offset parameter to that function.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><h1 class="c7" id="h.frymb2gvwbgb"><span class="c10">Tutorial 10: Instance Resources</span></h1><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 366.67px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 366.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Tutorial files:</span></p><p class="c6"><span class="c3 c0">10_InstanceResources.cpp</span></p><p class="c6"><span class="c3 c0">rt_10_shaders.rgen</span></p><p class="c6"><span class="c3 c0">rt_10_shaders.rchit</span></p><p class="c6"><span class="c0">rt_10_shaders.rmiss</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">This tutorial features fetching external resources via geometry instance id and resources inlined into SBT itself.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>First change is in the </span><span class="c8">VkGeometryInstance</span><span>&nbsp;struct filling. We now specify </span><span class="c8">instanceId</span><span>&nbsp;and </span><span class="c8">instanceOffset</span><span>&nbsp;for each of the instances. Both are set to index of the instance, i.e. 0, 1, or 2 (overall, we got 3 instances in this tutorial). </span><span class="c8">instanceId</span><span>&nbsp;represents custom index of the geometry available to the shaders. </span><span class="c8">instanceOffset</span><span>, however, is not used explicitly and specifies offset to the SBT hit shader group and custom data associated with the group. Look into </span><span class="c8">CreateShaderBindingTable()</span><span>&nbsp;function, it contains more code comparing to the previous tutorials. In addition to writing generation and miss shader group handles we create 3 (instead of 1) hit shader groups. Each group paired with the additional 4 floats written right after the hit shader group handle. Notice that, </span><span class="c8">_hitShaderAndDataSize</span><span>&nbsp;variable is set to contain the proper hit group stride and is later used during the call to </span><span class="c8">vkCmdTraceRaysNV()</span><span class="c20">&nbsp;</span><span>method. Furthermore, </span><span class="c8">CreateUniformBuffers()</span><span>&nbsp;method creates regular Vulkan uniform buffer containing 3 color vectors. To understand how much data can be put into SBT we can use </span><span class="c8">VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride</span><span>&nbsp;field (this is queried in the </span><span class="c8">InitRayTracing()</span><span>&nbsp;method of the </span><span class="c8">RayTracingApplication</span><span class="c1">&nbsp;class).</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>In the GLSL (</span><span class="c0">rt_10_shaders.rchit</span><span>) we declare regular uniform buffer (which contains 3 color vector filled above). </span><span class="c8">gl_InstanceCustomIndexNV</span><span>&nbsp;which corresponds to the </span><span class="c8">instanceId</span><span>&nbsp;is used to fetch the data from this buffer. To access SBT inlined data we have to define following declaration </span><span class="c8">layout(shaderRecordNV) buffer InlineData</span><span>. It contains </span><span class="c8">vec4 inlineData</span><span class="c1">&nbsp;which we have written to the SBT earlier (yet another color vector). We sum up these two vectors to get the final color. Since each of the components contain value of 0.5 (in R, G or B channels) for both uniform buffer and SBT data, the final values equal 1.0 for each of the color channels.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>Notice that to allow resource indexing using </span><span class="c8">instanceId</span><span>&nbsp;we use </span><span class="c8">GL_EXT_nonuniform_qualifier</span><span>&nbsp;shader extension via </span><span class="c8">nonuniformEXT()</span><span>&nbsp;function. On the application side this requires </span><span class="c8">VK_EXT_descriptor_indexing</span><span class="c1">&nbsp;extension which allows us to specify an unbound resource array.</span></p><p class="c6"><span class="c1">&nbsp;</span></p><h1 class="c7" id="h.w0pn50dujcgy"><span class="c10">Tutorial 11: Different Vertex Formats</span></h1><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 366.67px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 366.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span class="c1">Tutorial files:</span></p><p class="c6"><span class="c3 c0">11_DifferentVertexFormats.cpp</span></p><p class="c6"><span class="c0 c3">rt_11_shaders.rgen</span></p><p class="c6"><span class="c3 c0">rt_11_box.rchit</span></p><p class="c6"><span class="c3 c0">rt_11_icosahedron.rchit</span></p><p class="c6"><span class="c0">rt_11_shaders.rmiss</span></p><p class="c6"><span class="c1">&nbsp;</span></p><p class="c6"><span>In this tutorial we add object tracing with different vertex formats and materials. Basically, it&rsquo;s leveraging the technique introduced in the previous tutorial (although there&rsquo;s no SBT data this time). Normals, texture coordinates, textures are accessed through unbound descriptor arrays in hit shaders (box and icosahedron each have their own hit shader specified using </span><span class="c8">instanceOffset</span><span>). As previously we use </span><span class="c8">gl_InstanceCustomIndex</span><span>&nbsp;to sample the data from the buffers. This allows us to use different vertex formats and different materials with variable number of textures. Closest hit shaders only differ in </span><span class="c8">main()</span><span>&nbsp;function (specifically in vertex attributes fetching and albedo calculation).</span></p></body></html>